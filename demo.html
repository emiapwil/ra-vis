<!DOCTYPE html>
<html lang="en-us">

    <head>
        <script src="https://d3js.org/d3.v3.min.js"></script>
        <script src="https://d3js.org/d3-dispatch.v1.min.js"></script>
        <script src="https://d3js.org/d3-quadtree.v1.min.js"></script>
        <script src="https://d3js.org/d3-timer.v1.min.js"></script>
        <script src="https://d3js.org/d3-force.v2.min.js"></script>
        <style>
         .node {
             fill: #ccc;
             stroke: #fff;
             stroke-width: 2px;
         }

         .link {
             stroke: #777;
             stroke-width: 2px;
         }
        </style>
    </head>

    <body>
        <script>
         var draw = function(width, height, data) {
             var nodes = data.nodes.map(d => Object.create(d));
             var links = data.links.map(d => Object.create(d));

             var svg = d3.select('body').append('svg')
                         .attr('width', width)
                         .attr('height', height);

             // Now we create a force layout object and define its properties.
             // Those include the dimensions of the visualization and the arrays
             // of nodes and links.

             const simulation = d3.forceSimulation(nodes)
                                  .force("link", d3.forceLink(links))
                                  .force("charge", d3.forceManyBody());

             var link = svg.selectAll('.link')
                           .data(links)
                           .enter().append('line')
                           .attr('class', 'link')
                           .attr('x1', d => d.source.x)
                           .attr('y1', d => d.source.y)
                           .attr('x2', d => d.target.x)
                           .attr('y2', d => d.target.y);

             // Now it's the nodes turn. Each node is drawn as a circle.

             var node = svg.selectAll('.node')
                           .data(nodes)
                           .enter().append('circle')
                           .attr('class', 'node')
                           .attr('r', d => d.r)
                           .attr('cx', d => d.x)
                           .attr('cy', d => d.y)
                           .attr('label', d => d.label);

             d3.selectAll('.node')
               .on('mouseover', d => { console.log(d) });

             // We're about to tell the force layout to start its
             // calculations. We do, however, want to know when those
             // calculations are complete, so before we kick things off
             // we'll define a function that we want the layout to call
             // once the calculations are done.

             simulation.on('end', function() {

                 // When this function executes, the force layout
                 // calculations have concluded. The layout will
                 // have set various properties in our nodes and
                 // links objects that we can use to position them
                 // within the SVG container.

                 // First let's reposition the nodes. As the force
                 // layout runs it updates the `x` and `y` properties
                 // that define where the node should be centered.
                 // To move the node, we set the appropriate SVG
                 // attributes to their new values. We also have to
                 // give the node a non-zero radius so that it's visible
                 // in the container.

                 // We also need to update positions of the links.
                 // For those elements, the force layout sets the
                 // `source` and `target` properties, specifying
                 // `x` and `y` values in each case.
             });

             // Okay, everything is set up now so it's time to turn
             // things over to the force layout. Here we go.

             // By the time you've read this far in the code, the force
             // layout has undoubtedly finished its work. Unless something
             // went horribly wrong, you should see two light grey circles
             // connected by a single dark grey line. If you have a screen
             // ruler (such as [xScope](http://xscopeapp.com) handy, measure
             // the distance between the centers of the two circles. It
             // should be somewhere close to the `linkDistance` parameter we
             // set way up in the beginning (480 pixels). That, in the most
             // basic of all nutshells, is what a force layout does. We
             // tell it how far apart we want connected nodes to be, and
             // the layout keeps moving the nodes around until they get
             // reasonably close to that value.

             // Of course, there's quite a bit more than that going on
             // under the hood. We'll take a closer look starting with
             // the next example.

         };
         var width = 640, height = 480;

         // Define the data for the example. In general, a force layout
         // requires two data arrays. The first array, here named `nodes`,
         // contains the object that are the focal point of the visualization.
         // The second array, called `links` below, identifies all the links
         // between the nodes. (The more mathematical term is "edges.")

         // For the simplest possible example we only define two nodes. As
         // far as D3 is concerned, nodes are arbitrary objects. Normally the
         // objects wouldn't be initialized with `x` and `y` properties like
         // we're doing below. When those properties are present, they tell
         // D3 where to place the nodes before the force layout starts its
         // magic. More typically, they're left out of the nodes and D3 picks
         // random locations for each node. We're defining them here so we can
         // get a consistent application of the layout which lets us see the
         // effects of different properties.

         const url = 'http://localhost:5000/topology/Aarnet.json'
         const response = fetch(url)
             .then(response => response.json())
             .then(data => draw(width, height, data));
        </script>
    </body>
</html>
