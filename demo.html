<!DOCTYPE html>
<html lang="en-us">

    <head>
        <link rel="stylesheet" href="/assets/css/bootstrap.min.css">
        <script src="/assets/js/jquery-1.11.0.js"></script>
        <script src="/assets/js/bootstrap.min.js"></script>
        <script src="https://d3js.org/d3.v4.min.js"></script>
        <style>
         select {
             width: 100%;
         }

         textarea {
             width: 100%;
             min-height: 200px;
         }
         .node {
             fill: #ccc;
             stroke: #fff;
             stroke-width: 2px;
         }

         .node[selected=true] {
             fill: #000;
         }

         .link {
             stroke: #777;
             stroke-width: 2px;
         }
        </style>
    </head>

    <body>
        <div class="col-md-6">
            <p><label>Please select the demo topology</label></p>
            <select id="topolist" onchange="selectTopology(this.value)">
            </select>
            <p><label>Please type the route algebra expression</label></p>
            <textarea type="text">
            </textarea>
            <input type="submit" value="Submit" onclick="submitQuery()"/>
        </div>
        <div class="col-md-6">
            <svg></svg>
        </div>
        <script>

         var tridentFrontend = function () {
             const topoListUrl = 'http://localhost:5000/topologylist.json';
             const setTopologyUrl = 'http://localhost:5000/topology/{0}.json';
             const queryUrl = 'http://localhost:5000/query';

             var config = {
                 margin: 15,
                 width: 800,
                 height: 300,
                 radiusRange: [5, 15],
                 transitionDelay: 250
             }

             var currentQuery = {
                 expr: '',
                 selected: []
             };

             function prepareTopologyList() {
                 fetch(topoListUrl).then(r => r.json())
                                   .then(topoList => {
                                       topoList.forEach(topo => d3.select('select')
                                                                  .append('option')
                                                                  .attr('value', topo)
                                                                  .text(topo))
                                   });
             }

             function transform(v, rangeV, rangeE) {
                 const minV = rangeV[0], maxV = rangeV[1];
                 const minE = rangeE[0], maxE = rangeE[1];
                 return (v - minV) / (maxV - minV) * (maxE - minE) + minE;
             }

             function format(pattern) {
                 if (arguments.length == 0) {
                     return pattern;
                 }
                 var args = Array.prototype.slice.call(arguments, 1);
                 return pattern.replace(/\{(\d+)\}/g, function(m, i){
                     return args[i];
                 });
             }

             function fit(data, accessor, updater, rangeE) {
                 const minValue = d3.min(data, accessor);
                 const maxValue = d3.max(data, accessor);
                 const rangeV = [minValue, maxValue];

                 data.forEach(d => {
                     updater(d, transform(accessor(d), rangeV, rangeE));
                 });
             }

             function scaleTopologyLayout(nodes, links) {
                 const widthRange = [config.margin, config.width - config.margin];
                 const heightRange = [config.margin, config.height - config.margin];
                 const radiusRange = config.radiusRange;

                 fit(nodes, d => d.x, function (d, x) { d.x = x; }, widthRange);
                 fit(nodes, d => d.y, function (d, y) { d.y = y; }, heightRange);
                 fit(nodes, d => d.r, function (d, r) { d.r = r; }, radiusRange);
             }

             function initializeGraph(data) {
                 var nodes = data.nodes.map(d => Object.create(d));
                 var links = data.links.map(d => Object.create(d));

                 scaleTopologyLayout(nodes, links);

                 var svg = d3.select('svg')
                             .attr('width', config.width)
                             .attr('height', config.height);

                 const simulation = d3.forceSimulation(nodes)
                                      .force("link", d3.forceLink(links))
                                      .force("charge", d3.forceManyBody());

                 svg.selectAll('.link')
                    .data([])
                    .exit()
                    .remove();
                 svg.selectAll('.node')
                    .data([])
                    .exit()
                    .remove();
                 var link = svg.selectAll('.link')
                               .data(links)
                               .enter().append('line')
                               .attr('class', 'link')
                               .attr('x1', d => d.source.x)
                               .attr('y1', d => d.source.y)
                               .attr('x2', d => d.target.x)
                               .attr('y2', d => d.target.y)
                               .attr('id', d => d.id);

                 var node = svg.selectAll('.node')
                               .data(nodes)
                               .enter().append('circle')
                               .attr('class', 'node')
                               .attr('r', d => d.r)
                               .attr('cx', d => d.x)
                               .attr('cy', d => d.y)
                               .attr('id', d => d.index)
                               .attr('label', d => d.label);

                 d3.selectAll('.node')
                   .on('mouseover', d => { console.log(d) })
                   .on('mouseout', d => {console.log(d) });
                 d3.selectAll('.link')
                   .on('mouseover', d => { console.log(d) })
                   .on('mouseout', d => {console.log(d) });

             }

             function setTopology(topo) {
                 const url = format(setTopologyUrl, topo);
                 console.log(url);
                 fetch(url).then(r => r.json())
                           .then(data => initializeGraph(data));
             }

             function updatePath(oldPath, newPath) {
                 const svg = d3.select('svg');
                 svg.selectAll('.node')
                    .filter(d => (oldPath.findIndex(e => e == d.index) >= 0))
                    .attr('selected', 'false');
                 newPath.forEach(function (node, index) {
                     svg.selectAll('.node')
                        .filter(d => (node == d.index))
                        .transition()
                        .delay((index + 1) * config.transitionDelay)
                        .attr('selected', 'true');
                 });
             }

             function query(expr) {
                 fetch(queryUrl, {
                     body: expr,
                     method: 'POST'
                 }).then(r => r.json())
                   .then(path => {
                       updatePath(currentQuery.selected, path);
                       currentQuery.expr = expr;
                       currentQuery.selected = path;
                   });
             }

             return {
                 config: config,
                 prepareTopologyList: prepareTopologyList,
                 initializeGraph: initializeGraph,
                 setTopology: setTopology,
                 query: query
             };

         }();

         tridentFrontend.prepareTopologyList();

         function submitQuery() {
             const expr = $('textarea')[0].value;
             console.log(expr);
             tridentFrontend.query(expr);
         };

         function selectTopology(topo) {
             tridentFrontend.setTopology(topo);
         }

        </script>
    </body>
</html>
